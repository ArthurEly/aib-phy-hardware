package aib3d

import scala.math.min
import org.json4s.JsonDSL._
import org.json4s.jackson.JsonMethods.{pretty, render}
import doodle.core._
import doodle.core.format._
import doodle.syntax.all._
import doodle.java2d._
import cats.effect.unsafe.implicits.global

import chisel3._

import chisel3.experimental.{BaseModule, DataMirror}
import org.chipsalliance.cde.config.Parameters

import aib3d.io._

/** Generate bump map collateral */
object GenCollateral {
  /** Generates a JSON file with the IO cell instance name and location,
    * core pin name and location, and other physical design constraints.
    */
  def toJSON(iocells: Seq[BaseModule with IOCellBundle])
    (implicit params: AIB3DParams): String = {
    pretty(render(("bump map" -> params.flatBumpMap.map{ b =>
      val iocell = iocells.find(_.forBump == b)
      ("bump_name" -> b.bumpName) ~
      ("core_sig" -> (if (b.coreSig.isDefined) Some(b.coreSig.get.fullName) else None)) ~
      ("iocell_path" -> (if (iocell.isDefined) Some(iocell.get.toTarget.toString) else None)) ~
      ("bump_x" -> b.location.get.x) ~
      ("bump_y" -> b.location.get.y) ~
      ("pin_x" -> (if (b.coreSig.isDefined) Some(b.coreSig.get.pinLocation.get.x) else None)) ~
      ("pin_y" -> (if (b.coreSig.isDefined) Some(b.coreSig.get.pinLocation.get.y) else None)) ~
      ("submod_idx" -> (if (b.submodIdx.isDefined) Some(b.submodIdx.get.linearIdx) else None))
    })))
  }

  /** Generates a JSON file consumable by the Hammer VLSI flow tool.
    * This is a different from the JSON file generated by toJSON.
    */
  def toHammerJSON(iocells: Seq[BaseModule with IOCellBundle])
    // TODO: support mismatched pitchH/pitchV - need gcd of them
    // TODO: get bump cell name from params (tech-specific...)
    (implicit params: AIB3DParams): String = {

    // Bumps
    val pitch = min(params.gp.pitchH, params.gp.pitchV)
    val bumps =
      ("vlsi.inputs.bumps_mode" -> "manual") ~
      ("vlsi.inputs.bumps" ->
        ("x" -> params.bumpMap(0).length) ~
        ("y" -> params.bumpMap.length) ~
        ("pitch" -> pitch) ~
        // TODO: this must vary depending on how much edge logic there is
        ("global_x_offset" -> (
          if (params.pinSide == "W") params.ip.bumpOffset else 0.0)) ~
        ("global_y_offset" -> (
          if (params.pinSide == "S") params.ip.bumpOffset else 0.0)) ~
        ("cell" -> "TODO") ~
        ("assignments" -> params.flatBumpMap.map( b =>
          ("name" -> b.bumpName) ~
          // location is integer multiple of pitch, 1-indexed
          ("x" -> (b.location.get.x / pitch + 0.5).toInt) ~
          ("y" -> (b.location.get.y / pitch + 0.5).toInt)
        ))
      )

    // Pins
    val coreSigs = iocells.filter(_.forBump.coreSig.isDefined).map(_.forBump.coreSig.get)
    val sideMap = Map("N" -> "top", "S" -> "bottom", "E" -> "right", "W" -> "left")
    val pins =
      ("vlsi.inputs.pin_mode" -> "generated") ~
      ("vlsi.inputs.pin" ->
        ("generate_mode" -> "semi_auto") ~
        ("assignments" -> coreSigs.map( c =>
          ("pins" -> s"*${c.fullName}") ~
          ("side" -> sideMap(params.pinSide)) ~
          ("layers" -> Seq(c.pinLayer.get)) ~
          ("location" -> Seq(c.pinLocation.get.x, c.pinLocation.get.y))
        ))
      )

    // Placements
    val topWidth = (params.bumpMap(0).length + 1) * params.gp.pitchH +
      (if (!params.isWide) params.ip.bumpOffset else 0.0)
    val topHeight = (params.bumpMap.length + 1) * params.gp.pitchV +
      (if (params.isWide) params.ip.bumpOffset else 0.0)
    val topPlacement =
      ("vlsi.inputs.placement_constraints" -> Seq(
        ("path" -> "Patch") ~
        ("type" -> "toplevel") ~
        ("x" -> 0) ~
        ("y" -> 0) ~
        ("width" -> topWidth) ~
        ("height" -> topHeight) ~
        ("margins" ->
          ("left" -> 0) ~
          ("right" -> 0) ~
          ("top" -> 0) ~
          ("bottom" -> 0))
      )) ~
      ("vlsi.inputs.placement_constraints_meta" -> "append")
    val iocellPlacements =
      ("vlsi.inputs.placement_constraints" -> iocells.map( i =>
        // Replace Target delimiters with / for P&R
        // TODO: breaks if IO cell beneath top hierarchy
        ("path" -> i.toTarget.toString.replace("~", "").replace("|", "/")) ~
        ("type" -> "hardmacro") ~
        ("x" -> i.forBump.location.get.x) ~
        ("y" -> i.forBump.location.get.y) ~
        ("master" -> i.getClass.getSimpleName)
        // TODO: top layer for halos
      )) ~
      ("vlsi.inputs.placement_constraints_meta" -> "append")

    // SDC: clocks, delays, loads
    // Note: directions seem reversed (derived from bumps, not facing the core)
    val clocks = coreSigs.filter(c =>
      DataMirror.checkTypeEquivalence(c.ioType, Clock()) &&
      DataMirror.specifiedDirectionOf(c.ioType) == SpecifiedDirection.Output)
    val coreTxs = coreSigs.filter(c =>
      DataMirror.specifiedDirectionOf(c.ioType) == SpecifiedDirection.Output &&
      !DataMirror.checkTypeEquivalence(c.ioType, Clock()))
      .map(c => (c, "input"))
    val coreRxs = coreSigs.filter(c =>
      DataMirror.specifiedDirectionOf(c.ioType) == SpecifiedDirection.Input &&
      !DataMirror.checkTypeEquivalence(c.ioType, Clock()))
      .map(c => (c, "output"))
    val coreDirectioned = coreTxs ++ coreRxs
    val sdc =
      ("vlsi.inputs.clocks" -> clocks.map(c =>
        ("name" -> c.fullName) ~
        // TODO: parameterize frequency and uncertainty
        ("period" -> "250 ps") ~
        ("uncertainty" -> "25 ps")
      )) ~
      // TODO: this depends on the voltage-delay curve of the spec
      ("vlsi.inputs.delays" -> coreDirectioned.map{ case (c, dir) =>
        ("name" -> c.fullName) ~
        ("clock" -> c.relatedClk.get) ~
        ("direction" -> dir) ~
        ("delay" -> 50)
      }) ~
      // TODO: what's the actual load
      ("vlsi.inputs.default_output_load" -> "1 fF")
      // ("vlsi.inputs.output_loads" -> List("*", "1 fF"))
      // TODO: driver cell

    pretty(render(bumps merge pins merge topPlacement merge iocellPlacements merge sdc))
  }

  /** Generates a CSV file that can be imported into a spreadsheet
    * Each cell corresponds to a bump. If the bump has a corresponding core signal,
    * it is printed in the cell as well.
    */
  def toCSV(implicit params: AIB3DParams): String = {
    "Signal <-> Bump\n"+
    // Reverse rows to account for spreadsheet vs. layout
    params.bumpMap.reverse.map{ case r => r.map{ case b =>
      val coreSig = if (b.coreSig.isDefined) b.coreSig.get.fullName + " <-> " else ""
      s"${coreSig}${b.bumpName}"
    }.mkString(", ")}.mkString("\n")
  }

  /** Generates a PNG + PDF file that can be used to visualize the bump map.
    * This uses the scala doodle package and also opens a window for live visualization.
    */
  def toImg(implicit params: AIB3DParams): Unit = {
    require(params.gp.pattern == "square",
      "Only square bump patterns are supported for visualization")
    // Iterate row-wise (not in reverse order) and column-wise (in reverse order) using recursion
    // Scale by factor of 10 for legibility
    val scale = 10.0
    def constructCols(right: Picture[Unit], ba: Array[AIB3DBump]): Picture[Unit] = {
      if (ba.isEmpty) right
      else {
        val b = ba.head
        val coreSig = if (b.coreSig.isDefined) {
          b.coreSig.get.name + (if (b.coreSig.get.bitIdx.isDefined)
            "[" + b.coreSig.get.bitIdx.get.toString() + "]" else "")
        } else ""
        val bumpText = Picture.text(b.bumpName)
          .scale(scale / 16, scale / 16)
          .above(
            if (b.coreSig.isDefined)
              Picture.text(coreSig).scale(scale / 20, scale / 20)
            else Picture.empty
          )
        // An invisible square with a circle inside
        val bumpCircle = Picture.circle(scale * params.gp.pitch / 2)
        val bumpCell = bumpText.on(bumpCircle.fillColor(b match {
          case _: Pwr => Color.red
          case _: Gnd => Color.gray
          case _: TxSig => Color.lightGreen
          case _: RxSig => Color.lightBlue
          case _ => Color.white
        })).on(Picture.rectangle(
          scale * params.gp.pitchH, scale * params.gp.pitchV).noFill.noStroke)
        constructCols(bumpCell.beside(right), ba.tail)
      }
    }
    def constructRows(below: Picture[Unit], ba: Array[Array[AIB3DBump]]): Picture[Unit] = {
      if (ba.isEmpty) below
      else {
        val row = constructCols(Picture.empty, ba.head.reverse)
        constructRows(row.above(below), ba.tail)
      }
    }
    val bumps = constructRows(Picture.empty, params.bumpMap)

    // Overlay a dotted grid for submodules and some helpful text
    // Unfortunately, can't get bounding box or size of patch because it's a bug in doodle 0.19.0
    // Fixed for 0.20.0 but that is only available for Scala 3
    // So we have to do it manually - get dimensions of bump map and draw grid
    // (Accounts for default strokeWidth = 1)
    val (bumpsH, bumpsV) = (params.bumpMap(0).length, params.bumpMap.length)
    val bumpsWidth = bumpsH * scale * params.gp.pitchH
    val bumpsHeight = bumpsV * scale * params.gp.pitchV
    val gridWidth = bumpsH * scale * params.gp.pitchH / params.submodColsWR - 1
    val gridHeight = bumpsV * scale * params.gp.pitchV / params.submodRowsWR - 1
    def gridCols(right: Picture[Unit], x: Int): Picture[Unit] = {
      if (x == params.submodColsWR) right
      else {
        val gridRect = Picture.rectangle(gridWidth, gridHeight)
          .strokeColor(Color.gray).strokeDash(Array(scale / 2, scale / 5))
        gridCols(gridRect.beside(right), x + 1)
      }
    }
    def gridRows(below: Picture[Unit], y: Int): Picture[Unit] = {
      if (y == params.submodRowsWR) below
      else {
        val row = gridCols(Picture.empty, 0)
        gridRows(row.above(below), y + 1)
      }
    }
    val grid = gridRows(Picture.empty, 0)
    val titleText = s"""Bump Map: ${bumpsH} x ${bumpsV} bumps at
                        | ${params.gp.pitchH}um x ${params.gp.pitchV}um pitch"""
                        .stripMargin
    val titleBlock = Picture.text(titleText).scale(scale / 5, scale / 5).on(
      Picture.rectangle(bumpsWidth, scale / 2 * params.gp.pitchV).noFill.noStroke)
    // Rulers
    val leftRulerOffset = if (params.pinSide == "W") params.ip.bumpOffset else 0.0
    val leftRuler =
      (0 until bumpsV).foldLeft(Picture.empty)((below, y) =>
        Picture.text(((y + 0.5) * params.gp.pitchV + leftRulerOffset).toString)
        .on(Picture.rectangle(scale * params.gp.pitchH, scale * params.gp.pitchV).noFill.noStroke)
        .above(below))
      Picture.rectangle(scale / 2 * params.gp.pitchH, bumpsHeight).noFill.noStroke
    val bottomRulerOffset = if (params.pinSide == "S") params.ip.bumpOffset else 0.0
    val bottomRuler =
      Picture.text("Ruler (um)")
      .on(Picture.rectangle(scale * params.gp.pitchH + bottomRulerOffset,
                            scale * params.gp.pitchV).noFill.noStroke)
      .beside((0 until bumpsH).reverse.foldLeft(Picture.empty)((right, x) =>
        Picture.text(((x + 0.5) * params.gp.pitchH + bottomRulerOffset).toString)
        .on(Picture.rectangle(scale * params.gp.pitchH, scale * params.gp.pitchV).noFill.noStroke)
        .beside(right))
      )
    // Pin placement
    val rotation = params.pinSide match {
      case "N" | "S" => 90.degrees
      case _ => 0.degrees
    }
    val pins = params.flatBumpMap.filter(_.coreSig.isDefined)
      .foldLeft(Picture.empty){ case (on, b) =>
        val coreSig = b.coreSig.get
        val pinSize = params.ip.layerPitch(coreSig.pinLayer.get) / 1000 * scale
        val locX = (coreSig.pinLocation.get.x + params.gp.pitchH / 2) * scale - bumpsWidth / 2
        val locY = (coreSig.pinLocation.get.y + params.gp.pitchV / 2) * scale - bumpsHeight / 2
        val textOffset = scale
        val pinText = Picture.text(s"${coreSig.fullName} (${coreSig.pinLayer.get})")
          .scale(scale / 100, scale / 100).rotate(rotation)
        val pinRect = Picture.rectangle(pinSize, pinSize)
          .strokeColor(Color.black).strokeWidth(scale / 200)
          .at(locX, locY)
        params.pinSide match {
          case "N" => pinText.at(locX, locY + textOffset).on(pinRect).on(on)
          case "S" => pinText.at(locX, locY - textOffset).on(pinRect).on(on)
          case "E" => pinText.at(locX + textOffset, locY).on(pinRect).on(on)
          case "W" => pinText.at(locX - textOffset, locY).on(pinRect).on(on)
        }
      }

    // Final pic
    val bumpMapPic = titleBlock
                     .above(pins
                       .on(leftRuler
                         .beside(bumps.on(grid))
                       .above(bottomRuler)
                       )
                     )

    // Vector
    bumpMapPic.write[Pdf]("bumpmap.pdf")
    // Scalar
    bumpMapPic.write[Png]("bumpmap.png")
    // Live window (2x2 pixels = 1um^2)
    bumpMapPic.scale(2.0 / scale, 2.0 / scale).draw()
  }
}